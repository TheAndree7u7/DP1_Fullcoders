package com.plg.utils.simulacion;

import java.util.ArrayList;
import java.util.List;

import com.plg.dto.IndividuoDto;

import lombok.Getter;
import lombok.Setter;

/**
 * Gestiona el historial de paquetes generados por la simulaci√≥n y proporciona
 * utilidades para el frontend.
 */
@Getter
@Setter
public class GestorHistorialSimulacion {

    private static final List<IndividuoDto> historialSimulacion = new ArrayList<>();
    private static int indiceActualFrontend = 0;
    private static int contadorPaquetes = 0;
    private static boolean simulacionEnProceso = false;
    private static boolean simulacionPausada = false; // Nuevo flag para pausa

    /* --------------------------- MARCA DE ESTADO --------------------------- */
    public static synchronized void setEnProceso(boolean enProceso) {
        simulacionEnProceso = enProceso;
    }

    public static synchronized boolean isEnProceso() {
        return simulacionEnProceso;
    }

    // Nuevos m√©todos para pausa
    public static synchronized void setPausada(boolean pausada) {
        simulacionPausada = pausada;
        System.out.println("üîÑ SIMULACI√ìN " + (pausada ? "PAUSADA" : "REANUDADA"));
    }

    public static synchronized boolean isPausada() {
        return simulacionPausada;
    }

    /* ------------------------ OPERACIONES DE HISTORIAL --------------------- */

    public static synchronized void agregarPaquete(IndividuoDto paquete) {
        contadorPaquetes++;
        historialSimulacion.add(paquete);
        System.out.println("üì¶ PAQUETE AGREGADO #" + contadorPaquetes + " | Tiempo: "
                + paquete.getFechaHoraSimulacion() + " | Pedidos: " + paquete.getPedidos().size());
    }

    /**
     * Inserta un paquete parche en una posici√≥n espec√≠fica del historial.
     * Este m√©todo se usa cuando se genera un paquete de emergencia debido a una
     * aver√≠a.
     * 
     * @param paquete  El paquete parche a insertar
     * @param posicion La posici√≥n donde insertar el paquete (t√≠picamente
     *                 paqueteActual + 1)
     */
    public static synchronized void insertarPaqueteParche(IndividuoDto paquete, int posicion) {
        // Validar que la posici√≥n sea v√°lida
        if (posicion < 0 || posicion > historialSimulacion.size()) {
            System.err.println("‚ùå PAQUETE PARCHE: Posici√≥n inv√°lida " + posicion + ", historial size: "
                    + historialSimulacion.size());
            return;
        }

        contadorPaquetes++;
        historialSimulacion.add(posicion, paquete);

        // Calcular fitness del paquete parche (por ahora usar valor fijo)
        double fitness = 0.0; // Se podr√≠a mejorar para calcular el fitness real

        // Mostrar informaci√≥n completa como los otros paquetes
        System.out.println("------------------------");
        System.out.println("Tiempo actual: " + paquete.getFechaHoraSimulacion());
        System.out.println("Fitness algoritmo gen√©tico (paquete parche): " + String.format("%.1f", fitness));
        System.out.println("ü©π PAQUETE PARCHE INSERTADO #" + contadorPaquetes + " en posici√≥n " + posicion +
                " | Tiempo: " + paquete.getFechaHoraSimulacion() +
                " | Pedidos: " + paquete.getPedidos().size());

        // Mostrar estado de pedidos semanales (aproximado)
        List<com.plg.entity.Pedido> pedidosSemanal = com.plg.utils.Simulacion.getPedidosSemanal();
        int pedidosRestantes = pedidosSemanal != null ? pedidosSemanal.size() : 0;

        // Por ahora usamos valores aproximados para por atender y planificados
        int porAtender = paquete.getPedidos().size();
        int planificados = 0;

        System.out.println("üìä Estado: Pedidos semanales restantes: " + pedidosRestantes +
                ", Por atender: " + porAtender +
                ", Planificados: " + planificados);

        System.out.println("üìä DESPU√âS DEL PARCHE: Total paquetes=" + historialSimulacion.size() +
                ", Posici√≥n actual frontend=" + indiceActualFrontend);
    }

    /**
     * Elimina todos los paquetes futuros despu√©s del paquete actual.
     * Mantiene solo el paquete que est√° siendo consumido actualmente.
     * 
     * @return N√∫mero de paquetes eliminados
     */
    public static synchronized int eliminarPaquetesFuturos() {
        int paquetesAntesDeEliminar = historialSimulacion.size();
        int paqueteActualIndex = indiceActualFrontend;

        System.out.println("üóëÔ∏è ELIMINANDO PAQUETES FUTUROS:");
        System.out.println("   ‚Ä¢ Total paquetes antes: " + paquetesAntesDeEliminar);
        System.out.println("   ‚Ä¢ √çndice actual frontend (pr√≥ximo a consumir): " + paqueteActualIndex);
        System.out.println(
                "   ‚Ä¢ Paquete actual siendo consumido: "
                        + (paqueteActualIndex > 0 ? (paqueteActualIndex - 1) : "ninguno"));

        if (paqueteActualIndex >= historialSimulacion.size()) {
            System.out.println("‚ö†Ô∏è No hay paquetes futuros para eliminar (frontend al final del historial)");
            return 0;
        }

        // Eliminar todos los paquetes despu√©s del √≠ndice actual
        // El frontend ya consumi√≥ hasta indiceActualFrontend-1,
        // as√≠ que eliminamos desde indiceActualFrontend en adelante
        int paquetesAEliminar = historialSimulacion.size() - paqueteActualIndex;

        for (int i = historialSimulacion.size() - 1; i >= paqueteActualIndex; i--) {
            historialSimulacion.remove(i);
        }

        int paquetesDespuesDeEliminar = historialSimulacion.size();

        System.out.println("‚úÖ PAQUETES FUTUROS ELIMINADOS:");
        System.out.println("   ‚Ä¢ Paquetes eliminados: " + paquetesAEliminar);
        System.out.println("   ‚Ä¢ Total paquetes despu√©s: " + paquetesDespuesDeEliminar);
        System.out.println("   ‚Ä¢ Pr√≥ximo √≠ndice a consumir: " + indiceActualFrontend);

        return paquetesAEliminar;
    }

    public static synchronized IndividuoDto obtenerSiguientePaquete() {
        if (indiceActualFrontend < historialSimulacion.size()) {
            IndividuoDto paquete = historialSimulacion.get(indiceActualFrontend);
            int paqueteConsumido = indiceActualFrontend; // Guardar el √≠ndice antes de incrementar
            indiceActualFrontend++;
            System.out.println("üî• PAQUETE CONSUMIDO #" + paqueteConsumido + " | Tiempo: "
                    + paquete.getFechaHoraSimulacion() + " | Total disponibles: " + historialSimulacion.size());
            return paquete;
        }
        return null;
    }

    public static synchronized void reiniciarReproduccion() {
        int total = historialSimulacion.size();
        indiceActualFrontend = 0;
        System.out.println("üîÑ REPRODUCCI√ìN REINICIADA | Volviendo al paquete #1 | Total disponibles: " + total);
    }

    public static synchronized void limpiarHistorialCompleto() {
        int paquetesEliminados = historialSimulacion.size();
        historialSimulacion.clear();
        indiceActualFrontend = 0;
        contadorPaquetes = 0;
        simulacionEnProceso = false;
        simulacionPausada = false; // Reiniciar tambi√©n el flag de pausa
        System.out.println("üßπ HISTORIAL LIMPIADO COMPLETAMENTE | Paquetes eliminados: " + paquetesEliminados
                + " | Estado reiniciado | Pausa reiniciada");
    }

    /* ------------------------------ GETTERS -------------------------------- */

    public static synchronized int getTotalPaquetes() {
        return historialSimulacion.size();
    }

    public static synchronized int getPaqueteActual() {
        // Devolver el paquete que se est√° consumiendo actualmente
        // Si indiceActualFrontend es 0, no se ha consumido ning√∫n paquete a√∫n
        // Si indiceActualFrontend es N, se han consumido N paquetes, el actual es el
        // N-1
        return Math.max(0, indiceActualFrontend - 1);
    }

    public static synchronized int getContadorPaquetes() {
        return contadorPaquetes;
    }

    public static synchronized List<IndividuoDto> getHistorial() {
        return new ArrayList<>(historialSimulacion);
    }

    /**
     * Obtiene el paquete en una posici√≥n espec√≠fica sin modificar el √≠ndice actual.
     * √ötil para obtener informaci√≥n de paquetes para generar paquetes parche.
     * 
     * @param indice La posici√≥n del paquete a obtener
     * @return El paquete en la posici√≥n especificada, o null si no existe
     */
    public static synchronized IndividuoDto obtenerPaquetePorIndice(int indice) {
        if (indice >= 0 && indice < historialSimulacion.size()) {
            return historialSimulacion.get(indice);
        }
        return null;
    }
}